---
title: HTTP Request Smuggling Vulnerability
subtitle: Explination of request smuggling vulnerability
slideshow_title: Request Smuggling Vulnerability
author: Basel Al-Sayed
author_title: "Software Engineer @ Foothill Solutions"
description: Explination of request smuggling vulnerability
layout: slideshow
date: 2021-11-27
published: true
image: /assets/img/logo.png
---

<section>
    <h2>Introduction</h2>
    <ul>
        <li>Http requests are sent over network in binary data format.</li>
        <li>the server needs to interpret that network traffic and convert it to multiple requests.</li>
    </ul>
</section>

<section>
    <h2>Introduction</h2>
    <ul>
        <li>Since there are always will be subsequent requests to the target server, It needs to use a mechanism to determine the boundary of each request (i.e where the request begins, ends and the next request begins) and so on.</li>
        <li>Each request must have be supplied with (in the header) of what the mechanism is used to determine its boundary.</li>
    </ul>
</section>

<section>
    <h2>Specifying the Boundary</h2>
    <p>There are two approaches to determine the boundary of each single request:</p>
    <ol>
        <li>
            <b>Content Length Header:</b>
            it specifies the length of the message body in bytes
            <div style="flex: 1 1 0%;">
                <img src="/assets/slideshows/2021-11-27-basel-alsayed-request-smuggling-vulnerability/content-length-techinque.png">
            </div>
        </li>
    </ol>
</section>

<section>
    <h2>Specifying the Boundary</h2>
    <ol start="2">
        <li>
            <b>Transfer Encoding Header:</b>
            used to specify that the message body uses chunked encoding.
            <ul>
                <li>The message body contains one or more chunks of data.
                </li>
                <li>Each chunk consists of (the chunk size in bytes, a new line, and the chunk’s contents).</li>
                <li>The request body is terminated with a chunk of size zero.</li>
            </ul>
        </li>
    </ol>
</section>

<section>
    <h2>Specifying the Boundary</h2>
    <div style="flex: 1 1 0%;">
        <img src="/assets/slideshows/2021-11-27-basel-alsayed-request-smuggling-vulnerability/transfer-encoding-technique.png">
    </div>
</section>

<section>
    <h2>The Architecture</h2>
    <div style="flex: 1 1 0%;">
        <img src="/assets/slideshows/2021-11-27-basel-alsayed-request-smuggling-vulnerability/the-arch.PNG">
    </div>

</section>

<section>
    <h2>The Architecture</h2>
    <ul>
        <li>The frontend server could be: caching server, proxy, firewall, load balancer</li>
        <li>The backend server: is the resource server</li>
    </ul>
</section>

<section>
    <h2>The Issue</h2>
    <ul>
        <li>The issue appear when we have more that one server transferring the request</li>
        <li>Each server is free to use and support any mechanism to determine the request boundary</li>
        <li>
            The issue arises when the servers processing the same request use different mechanisms.
            <ul>
                <li>
                    So what is considered as an end of request to one server, it might be not considered the same from the second server perspective and  it keep waiting for the request to complete (and vise versa)
                </li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>The Issue</h2>
    <p>What if the Servers has determined the boundary in a wrong way?</p>
    <ul>
        <li>The server has to determine the request boundary in order to server it correctly (fulfill the request purpose)</li>
        <li>The server serves requests are from different clients, so each request should be totally separated from other requests, If not so, the requests will be overlapped and wrong responses will be sent to the users which may affect the user experience, privacy and the application security.</li>
    </ul>
</section>

<section>
    <h2>HTTP Request Smuggling</h2>
    <p>HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users</p>
</section>

<section>
    <h2>Request Smuggling Attack Requirements</h2>
    <ul>
        <li>When we have two or more servers process the same request. (ex. load balancer arch.)</li>
        <li>The two mechanisms have to be specified in the request (content Length and transfer encoding)</li>
    </ul>
</section>
<section>
    <h2>Request Smuggling Attack Requirements</h2>
    <ul>
        <li>Server does not support the transfer encoding technique
            <ul>
                <li>When both techniques are specified, the transfer encoding well be considered and the content length will be ignored.</li>
            </ul>
        </li>
    </ul>
</section>
<section>
    <h2>The Impact of Request Smuggling</h2>
    <ul>
        <li>Bad user experience</li>
        <li>Session Hijacking</li>
        <li>Bypass security controls</li>
        <li>Cache poisoning</li>
        <li>Bypassing client authentication</li>
    </ul>
</section>

<section>
    <h2>How It works?</h2>
    <p>Consider the following scenario, in this network traffic which sent by a client application, the two target servers may interpret it differently!</p>
    <div style="flex: 1 1 0%;">
        <img src="/assets/slideshows/2021-11-27-basel-alsayed-request-smuggling-vulnerability/request-smaggling-scenario.png">
    </div>
</section>

<section>
    <h2>How It works?</h2>
    <p>Let’s assume that:</p>
    <ul>
        <li>the front-end server uses the content length: so it will see two requests for /home</li>
        <li>The backend server uses the transfer encoding: so it will see one request for /home and another request for /admin</li>
    </ul>
    <div style="flex: 1 1 0%;">
        <img src="/assets/slideshows/2021-11-27-basel-alsayed-request-smuggling-vulnerability/request-smaggling-scenario.png">
    </div>
</section>

<section>
    <p style="text-align:center; font-size: 30px">
        So What ?!
        <br/>
        Where is the issue here ?
    </p>
</section>

<section>
    <p style="text-align:center; font-size: 30px">
        The server will send back wrong responses accordingly
        <br/>
        <span style="color: red">which will harm the user experience</span>
        <br/>
        <br/>
        And ... guess what else?
    </p>
</section>

<section>
    <h2>Exploiting request smuggling vulnerabilities: bypass front-end security controls</h2>
    <ul>
        <li>In a situation where the front-end web server is used to implement some security controls, deciding whether to allow individual requests to be processed. Allowed requests are forwarded to the back-end server.</li>
    </ul>
</section>

<section>
    <h2>Exploiting request smuggling vulnerabilities: bypass front-end security controls</h2>
    <ul>
        <li>
            The back-end server will assume every request reached to it is allowed and will process it
            <span style="color: red">
                without further checking
            </span>
        </li>
        <li>
            In the previous scenario, assume that is the case, so the user who access to /home
            <span style="color: red">
                will always get access to /admin
            </span>
        </li>
    </ul>
</section>

<section>
    <h2>Protection Against HTTP Request Smuggling</h2>
    <ul>
        <li>
            Use the same boundary mechanism in all servers that process the requests as much as possible.
        </li>
        <li>
            Detect and block ambiguous requests
        </li>
    </ul>
</section>

<section>
    <h2>Protection Against HTTP Request Smuggling</h2>
    <ul>
        <li>
            Prefer HTTP/2 over HTTP/1: since it uses a robust mechanism for determining the length of requests
            <ul>
                <li>
                    Much better when it’s used as end-to-end (i.e both servers uses the HTTP/2)
                </li>
                <li>
                    Since some servers only support HTTP/1 we may have to perform HTTP downgrade (from HTTP/2 to HTTP/1)
                </li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>HTTP Downgrading Attack</h2>
    <ul>
        <li>The attacker forces a network channel to switch to an unprotected or less secure data transmission standard.</li>
        <li>It is a man-in-the-middle attack, in which the traffic is intercepted.
        </li>
        <li>
            <b>Example:</b>
            redirecting a user from an HTTPS version of a resource to an HTTP copy.</li>
        <li>
            <b>To avoid such attack:</b>
            make sure you validate the rewritten request against the HTTP/1.1 specification and standards.
        </li>
    </ul>
</section>
<section>
    <h2>Structures are vulnerable to the attack</h2>
    <ul>
        <li>Caching server</li>
        <li>Proxy server: any sever that prevent direct access to the backend server</li>
        <li>Load balancer</li>
        <li>WAF (Firewall)</li>
    </ul>
</section>
